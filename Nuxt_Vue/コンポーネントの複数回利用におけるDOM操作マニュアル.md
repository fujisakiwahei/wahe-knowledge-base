# コンポーネントの複数回利用におけるDOM操作マニュアル

## 0. コンポーネントを複製して、違うものとして呼び出すと解消されるパターンもあり。

## 1. 現象：なぜ2つ目以降が正しく動かないのか
VueやNuxtで同じコンポーネントを1つのページ内に複数配置した際、JavaScript（特にGSAPやScrollTrigger）が期待通りに動作しない主な原因は **「要素の特定（スコープ）の重複」** です。

### 主な原因
*   **セレクタの衝突**: `gsap.to('.image', ...)` のようにクラス名で指定すると、ページ内のすべての `.image` を操作しようとしてしまいます。
*   **計算の基準ミス**: `ScrollTrigger` が「ページ全体の最初に見つかった要素」を基準にスクロール位置を計算してしまい、2つ目以降のコンポーネントが自分の位置を正しく認識できなくなります。

---

## 2. 解決策：スコープ（範囲）の限定

コンポーネントごとに独立した動作を保証するためには、**「そのコンポーネント自身の範囲内」** だけで要素を探すように制限する必要があります。

### A. GSAP Context を使用する（推奨）
GSAP 3.11以降で導入された `gsap.context()` を使うのが最も確実で安全な方法です。

```typescript
// 1. コンポーネントのルート要素に ref をつける
const sectionRef = ref<HTMLElement | null>(null)

onMounted(() => {
  if (!sectionRef.value) return

  // 2. context を作成し、第2引数にルート要素を渡す
  ctx = gsap.context((self) => {
    // この関数内では、クラス名指定（'.child'）を使っても
    // 「sectionRef の中にある .child」だけが自動的に対象になります
    gsap.to('.child', { 
      scrollTrigger: {
        trigger: sectionRef.value, // 自分の親要素をトリガーにする
        start: 'top bottom',
        scrub: true
      },
      y: -50 
    })
  }, sectionRef.value) // ← 第2引数でスコープを限定！
})
```

### B. Vue の `ref` を直接渡す
クラス名（文字列）ではなく、Vueが取得した具体的なDOM要素（`ref.value`）を直接GSAPに渡します。

```typescript
// クラス名ではなく ref の値を直接渡すことで、他コンポーネントとの混同を防ぐ
gsap.fromTo(imageRef.value, { y: 100 }, { y: -50 })
```

---

## 3. 実装時のチェックリスト

コンポーネントを自作する際は、以下の3点を必ず確認してください。

1.  **ルート要素に `ref` が設定されているか？**
    *   コンポーネント全体を囲むタグ（`<section>`など）に `ref` を設定し、それを基準にします。
2.  **`gsap.context` の第2引数にその `ref` を渡しているか？**
    *   `gsap.context(() => { ... }, scope)` の `scope` 部分にルート要素を渡します。
3.  **クリーンアップ（revert）を行っているか？**
    *   `onUnmounted` で `ctx.revert()` を実行します。これを忘れると、ページ遷移後も古いアニメーション設定がメモリに残り、動作が不安定になります。

---

## 4. 今回のケースの振り返り
`ContactSection.vue` では、`ScrollTrigger` の計算が1つ目のインスタンスに引きずられていました。修正によって「各コンポーネントが自分自身の位置を基準に計算する」ようになったため、2つ目以降も正しく視差効果（パララックス）が動作するようになりました。

**「コンポーネントは常に複数配置される可能性がある」** という前提で、常に `ref` と `context` のスコープを意識することが重要です。

---
